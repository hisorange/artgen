:WSN:

# Defining the used building blocks of the language.

EOL = "\n" -> whitespace .
syntax SPACE = " " -> whitespace .
syntax TAB = "\t" -> whitespace .
syntax WS = { SPACE | EOL | TAB } -> whitespace .
syntax UNDERSCORE = "_" .
syntax SINGLE_QUOTE = "'" .
syntax DOUBLE_QUOTE = '"' .
syntax QUOTES = SINGLE_QUOTE | DOUBLE_QUOTE .
syntax LETTER =  /[a-zA-Z]/ .
syntax DIGIT  = /[0-9]/ .
syntax SYMBOL = "=" | ";" | "[" | "]" | "{" | "}" | "(" | ")" | "." | "|" | "\\" | "#" | "," | "!" | "<" | ">" | "/" | ":" | "-" | "~" | "&" | "$" .
syntax REGEXP = "/" { LETTER | "-" | "[" | "]" | DIGIT } "/" .

# Raising the complexity into logical groups.

syntax CHARACTER = LETTER | DIGIT | SYMBOL .
syntax TEXT = LETTER | DIGIT | SYMBOL | SPACE | TAB | QUOTES .

# Defining the language elements.

syntax ALIAS      = "&" IDENTIFIER .
token IDENTIFIER = LETTER { LETTER | UNDERSCORE } .
syntax LITERAL    =
  SINGLE_QUOTE { CHARACTER | SPACE | SYMBOL | UNDERSCORE | DOUBLE_QUOTE } SINGLE_QUOTE |
  DOUBLE_QUOTE { CHARACTER | SPACE | SYMBOL | UNDERSCORE | SINGLE_QUOTE } DOUBLE_QUOTE .
syntax FACTOR     = "{" EXPRESSION "}" | "(" EXPRESSION ")" | "[" EXPRESSION "]" | &REGEXP | &LITERAL | &IDENTIFIER | &ALIAS .
syntax TERM       = WS FACTOR { WS FACTOR } WS .

token EXPRESSION = TERM { "|" TERM } .
token PRODUCTION_TYPE = "token" | "syntax" .
token PRODUCTION = { WS | COMMENT } PRODUCTION_TYPE WS IDENTIFIER WS "=" EXPRESSION { CHANNEL } "." { WS | COMMENT } .
token SYNTAX     = [GRAMMAR] { PRODUCTION } .

# Custom syntax extensions over the WSN definition.

# Defin a grammar name like :PHP: at the begining of the file.
token GRAMMAR_NAME = LETTER { LETTER } .
token GRAMMAR = ":" GRAMMAR_NAME ":" .

# The comment rule and logic was created without coding!
token COMMENT = "#" { TEXT } [ EOL ] -> comment .

# Parsing channel, can route a production into different channels.
# Useful to send misc like comment and whitespace into the void :D
token CHANNEL    = "->" WS LETTER { LETTER } WS .